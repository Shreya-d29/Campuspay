#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1
    bytecblock "total_transactions" "total_volume" 0x151f7c75
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/campuspay/contract.py:6
    // self.total_transactions = UInt64(0)
    bytec_0 // "total_transactions"
    intc_0 // 0
    app_global_put
    // smart_contracts/campuspay/contract.py:7
    // self.total_volume = UInt64(0)
    bytec_1 // "total_volume"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/campuspay/contract.py:4
    // class CampusPay(ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@13
    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert
    pushbytess 0x3c2ffb7e 0x20760649 0xe67daf51 0x7e4d3961 // method "greet()string", method "register_transaction(uint64)uint64", method "get_stats()(uint64,uint64)", method "pay_and_log(pay)string"
    txna ApplicationArgs 0
    match main_greet_route@6 register_transaction get_stats pay_and_log
    err

main_greet_route@6:
    // smart_contracts/campuspay/contract.py:9
    // @arc4.abimethod()
    pushbytes 0x151f7c75004057656c636f6d6520746f2043616d707573506179202d2054686520536f6369616c2046696e616e636520506c6174666f726d20666f722053747564656e747321
    log
    intc_1 // 1
    return

main___algopy_default_create@13:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return


// contract.CampusPay.register_transaction[routing]() -> void:
register_transaction:
    // smart_contracts/campuspay/contract.py:13
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    pushint 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/campuspay/contract.py:15
    // self.total_transactions += 1
    intc_0 // 0
    bytec_0 // "total_transactions"
    app_global_get_ex
    assert // check self.total_transactions exists
    intc_1 // 1
    +
    bytec_0 // "total_transactions"
    swap
    app_global_put
    // smart_contracts/campuspay/contract.py:16
    // self.total_volume += amount
    intc_0 // 0
    bytec_1 // "total_volume"
    app_global_get_ex
    assert // check self.total_volume exists
    +
    bytec_1 // "total_volume"
    swap
    app_global_put
    // smart_contracts/campuspay/contract.py:17
    // return self.total_transactions
    intc_0 // 0
    bytec_0 // "total_transactions"
    app_global_get_ex
    assert // check self.total_transactions exists
    // smart_contracts/campuspay/contract.py:13
    // @arc4.abimethod()
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// contract.CampusPay.get_stats[routing]() -> void:
get_stats:
    // smart_contracts/campuspay/contract.py:21
    // return (self.total_transactions, self.total_volume)
    intc_0 // 0
    bytec_0 // "total_transactions"
    app_global_get_ex
    assert // check self.total_transactions exists
    intc_0 // 0
    bytec_1 // "total_volume"
    app_global_get_ex
    assert // check self.total_volume exists
    // smart_contracts/campuspay/contract.py:19
    // @arc4.abimethod()
    swap
    itob
    swap
    itob
    concat
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// contract.CampusPay.pay_and_log[routing]() -> void:
pay_and_log:
    // smart_contracts/campuspay/contract.py:23
    // @arc4.abimethod()
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/campuspay/contract.py:25-26
    // # Verify payment is to the contract (optional, depending on use case)
    // assert payment.amount > UInt64(0), "Amount must be greater than 0"
    gtxns Amount
    dup
    assert // Amount must be greater than 0
    // smart_contracts/campuspay/contract.py:28
    // self.total_transactions += 1
    intc_0 // 0
    bytec_0 // "total_transactions"
    app_global_get_ex
    assert // check self.total_transactions exists
    intc_1 // 1
    +
    bytec_0 // "total_transactions"
    swap
    app_global_put
    // smart_contracts/campuspay/contract.py:29
    // self.total_volume += payment.amount
    intc_0 // 0
    bytec_1 // "total_volume"
    app_global_get_ex
    assert // check self.total_volume exists
    +
    bytec_1 // "total_volume"
    swap
    app_global_put
    // smart_contracts/campuspay/contract.py:23
    // @arc4.abimethod()
    pushbytes 0x151f7c7500205472616e73616374696f6e206c6f67676564207375636365737366756c6c792e
    log
    intc_1 // 1
    return
